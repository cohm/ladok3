This is the documentation of the command-line interface module ([[cli]]) of the 
[[ladok3]] package, [[<<cli.py>>]].

The command-line interface is divided into subcommands, similar to Git.
Currently, we provide the following commands:
\begin{description}
\item[data]
The command outputs all results for all rounds of a course in CSV format.
\end{description}


\section{Overview of the source code and dependencies}

We use [[argparse]] with [[argcomplete]] to handle the command-line interface.
We use [[appdirs]] to handle configuration directories on various systems, we 
set up a global [[dirs]] that we can use.
<<cli.py>>=
#!/bin/env python3
"""A command-line interface for LADOK 3"""

import appdirs
import argcomplete, argparse
import json
import os
import pickle
import re
import sys
import traceback

<<modules>>

dirs = appdirs.AppDirs("ladok", "dbosk@kth.se")

<<functions>>
<<command-line interface>>
@


\section{A command-line interface}%
\label{command-line-interface}

The idea is that we have the basic command that can take some options and 
ultimately some subcommand.
The subcommands do the heavy lifting.
We use a standard Pythonic if-main construction.
<<command-line interface>>=
def main():
  """Run the command-line interface for the ladok command"""
  <<process command-line options>>

if __name__ == "__main__":
  try:
    main()
    sys.exit(0)
  except Exception as e:
    err(-1, e)
@

We want uniform error handling.
We will use the function [[err]] for errors and [[warn]] for warnings, both 
inspired by err(3) and warn(3) in the BSD world.
<<functions>>=
def err(rc, msg):
  print(f"{sys.argv[0]}: error: {msg}", file=sys.stderr)
  traceback.print_exc(file=sys.stderr)
  sys.exit(rc)

def warn(msg):
  print(f"{sys.argv[0]}: {msg}", file=sys.stderr)
@


\subsection{Process command-line options}%
\label{process-command-line-options}

The main part done here is to set up a [[LadokSession]] object~[[ls]].
We can do this in two ways:
\begin{enumerate*}
\item create a new object using the user's credentials to log in; or
\item restore the [[ls]] object from a previous run.
\end{enumerate*}

We'll use [[argparse]] to parse the command-line options.
<<process command-line options>>=
argp = argparse.ArgumentParser(
  description="Command-line interface for LADOK3",
  epilog="Web: https://github.com/dbosk/ladok3"
)
<<add global configuration options>>
subp = argp.add_subparsers(
  title="commands",
  dest="command",
  required=True
)
<<add subparsers to subp>>
argcomplete.autocomplete(argp)
args = argp.parse_args()
<<process global configuration options>>
<<create or restore the LadokSession ls>>
<<execute subcommand>>
<<save LadokSession ls>>
@

For each subcommand, we will add a subparser ([[subp.add_parser]]) that will 
set the [[func]] attribute.
Then we can execute the correct function and let that function check the 
remaining arguments.
We must also pass on a LADOK session object~[[ls]].
<<execute subcommand>>=
if "func" in args:
  args.func(ls, args)
@


\section{Create the LadokSession~[[ls]]}

We have several options for creating the LadokSession object~[[ls]] that must 
be passed to the subcommand:
\begin{enumerate}
\item The first one is to read the credentials from a configuration file (or 
the environment) and create the [[ls]] object by instantiating the 
[[LadokSession]] class (technically the [[LadokSessionKTH]] class).
\item Read a pickled [[LadokSession]] object from file.
\end{enumerate}
The second option allows us to save time by not having to reestablish an 
authenticated session to LADOK.
The authentication step takes much more time that individual LADOK requests.

This leads to the following approach.
<<create or restore the LadokSession ls>>=
ls = restore_ladok_session()
if not ls:
  ls = ladok3.LadokSessionKTH(LADOK_USER, LADOK_PASS)
@
<<save LadokSession ls>>=
store_ladok_session(ls)
@


\subsection{Saving and restoring the [[LadokSession]] object}

Now we need to implement the [[store_ladok_session]] and 
[[restore_ladok_session]] functions.
For storing, we simply use [[pickle.dump]] to a suitably chosen file.
For restoring, we simply [[pickle.load]] from the same suitably chosen file.
<<functions>>=
def store_ladok_session(ls):
  if not os.path.isdir(dirs.user_cache_dir):
    os.mkdir(dirs.user_cache_dir)

  file_path = dirs.user_cache_dir + "/LadokSession"

  with open(file_path, "wb") as file:
    pickle.dump(ls, file)
  
def restore_ladok_session():
  file_path = dirs.user_cache_dir + "/LadokSession"

  if os.path.isfile(file_path):
    with open(file_path, "rb") as file:
      return pickle.load(file)

  return None
@


\subsection{Configuration}

We must read the following configuration:
\begin{enumerate}
\item credentials for LADOK, \ie username ([[LADOK_USER]]) and password 
([[LADOK_PASS]]) of the LADOK user;
\end{enumerate}

The credentials will be stored in a configuration file, [[config.json]], in 
JSON format, \eg:
\begin{minted}{json}
{
  "username": "the username",
  "password": "the password"
}
\end{minted}
They can alternatively be provided through the environment variables 
[[LADOK_USER]] and [[LADOK_PASS]].
The environment has priority over the configuration file.
The configuration file is located in [[dirs.user_config_dir]].
This directory varies by platform.

We want to allow the user to specify different locations for the configuration.

\paragraph{Location of configuration files}

We want the user to be able to specify the location of the configuration 
file.
<<add global configuration options>>=
argp.add_argument("-f", "--config-file",
  default=f"{dirs.user_config_dir}/config.json",
  help="Path to configuration file "
    f"(default: {dirs.user_config_dir}/config.json) "
    "or set LADOK_USER and LADOK_PASS environment variables.")
@ Since we provide the default value here, we can always rely on it to be 
available, so we can use [[args.config_file]] directly when we get the 
credentials.

We want to read the LADOK credentials to construct a LADOK-session 
object~[[ls]] that will be used throughout.
<<process global configuration options>>=
LADOK_USER, LADOK_PASS = load_credentials(args.config_file)
@

\paragraph{User credentials}

We can read the credentials from two places: the environment or a configuration 
file.
We try the environment first and the configuration file second.

The [[load_credentials]] function will try to get the LADOK user credentials 
from the configuration.
The environment is given priority, so it tries that first.
If it succeeds, it returns those credentials.
Otherwise, it tries to find the credentials in a configuration file.
<<functions>>=
def load_credentials(filename):
  """Load credentials from environment or file named filename"""
  try:
    user = os.environ["LADOK_USER"]
    passwd = os.environ["LADOK_PASS"]
    return user, passwd
  except:
    pass

  try:
    with open(filename) as conf_file:
      config = json.load(conf_file)
    return config["username"], config["password"]
  except:
    raise Exception("Cannot find credentials.")
@


\section{Managing the cache}

We need a command to control the cache.
For this purpose we provide the [[cache]] subcommand.
This command will in turn have subcommands.
<<add subparsers to subp>>=
cache_parser = subp.add_parser("cache",
  help="Manage cache",
  description="Manages the cache of LADOK data"
)
cache_subp = cache_parser.add_subparsers(
  title="subcommands",
  dest="subcommand",
  required=True
)
<<add subcommands to cache command>>
@


\subsection{Clear the cache}

Since the cache stores sensitive data (student data) and the login credentials, 
we want to be able to clear the cache.
<<add subcommands to cache command>>=
cache_clear = cache_subp.add_parser("clear",
  help="Clear the cache",
  description="Clears everything from the cache"
)
cache_clear.set_defaults(func=clear_cache)
@

The [[clear_cache]] function will clear the cache.
We simply remove the existing cache file and then exit.
If we don't exit using [[sys.exit]], the main program will write the cache back 
again on its exit.
<<functions>>=
def clear_cache(ls, args):
  os.remove(dirs.user_cache_dir + "/LadokSession")
  sys.exit(0)
@


\section{Subcommands}

To add a subcommand we must add a subparser to the [[subp]] parser object from 
above, we do this in [[<<add subparsers to subp>>]].
Every subcommand exists in a separate module and that module provides the 
function [[add_command_options]] that takes [[subp]] as an argument.

We add the [[data]] subcommand.
<<modules>>=
import ladok3.data
@
<<add subparsers to subp>>=
ladok3.data.add_command_options(subp)
@

We add the [[report]] command.
<<modules>>=
import ladok3.report
@
<<add subparsers to subp>>=
ladok3.report.add_command_options(subp)
@

