We want to compute statistics based on LADOK data.
We want to answer the following questions:
\begin{enumerate}
\item\label[question]{QGradeDistInCourse} What are the grade distribution of a 
course round?
\item\label[question]{QGradeDistDiffYears} How do grade distributions differ 
between years (\ie rounds) for the same course?
\item\label[question]{QGradeDistDiffCourses} How do grade distributions differ 
between (similar) courses?
\item How is the throughput distribution of a course?
\item How do throughput distributions vary between years?
\end{enumerate}

We provide the program [[stats-data.py]] to extract the necessary data from 
LADOK (\cref{StatsData}).
This program will produce CSV-formated data to answer those questions.
The data is formated like this:
\begin{itemize}
\item course,
\item round,
\item component,
\item student (pseudonym),
\item grade,
\item normalized time.
\end{itemize}

Then we provide ways to analyze that data.
We answer
\cref{QGradeDistInCourse,QGradeDistDiffYears,QGradeDistDiffCourses}
in \cref{GradeDistributions}.

\section{Getting the data, [[stats-data.py]]}\label{StatsData}

We have the [[stats-data.py]] program.
We take a course code as an argument, then we produce CSV data for that course.

We need access to LADOK through the [[ladok3]] module.
We will also write data to disk in CSV form, so we need the [[csv]] module.
<<stats-data.py>>=
import argparse
import csv
import datetime
import ladok3
import os
import sys

<<data functions>>

def main():
  <<process stats-data command-line arguments into args>>
  <<produce data about course specified in args>>

if __name__ == "__main__":
  main()
@

We set up the argument parser and parse the command line.
<<process stats-data command-line arguments into args>>=
parser = argparse.ArgumentParser(
  description="Produce CSV data from LADOK about a course")

parser.add_argument("course_code",
  help="The course code of the course to analyze")

args = parser.parse_args()
@


\subsection{Producing data}

We fetch the data from LADOK and print it in CSV format to standard out 
([[sys.stdout]]).
This way the user can deal with how to store the data.
<<produce data about course specified in args>>=
ladok = ladok3.LadokSessionKTH(
        os.environ["KTH_LOGIN"], os.environ["KTH_PASSWD"],
        test_environment=True) # for experiments

data_writer = csv.writer(sys.stdout)
course_rounds = ladok.search_course_rounds(code=args.course_code)

data_writer.writerow([
  "Course", "Round", "Component", "Student", "Grade", "Time"
])
for course_round in course_rounds:
  data = extract_data_for_round(ladok, course_round)
  data = clean_data(data)

  for student, component, grade, time in data:
    data_writer.writerow(
      [course_round.code, course_round.round_code, component,
        student, grade, time]
    )
@


\subsection{Extracting data for a round}

Now we want to extract data for a given course round.
This is done by the function~[[extract_data_for_round]].
We need access to LADOK through the [[ladok]] object of type [[LadokSession]].
We also need the course round through the [[course_round]] object of type 
[[CourseRound]].
<<data functions>>=
def extract_data_for_round(ladok, course_round):
  <<compute start and length of the course>>
  <<get the results for the course round>>

  for result in results:
    student = result["Student"]["Uid"]

    for component_result in result["ResultatPaUtbildningar"]:
      if component_result["HarTillgodoraknande"]:
        continue

      <<get the component result data>>
      <<extract component code from result data>>
      <<extract grade and normalized date from result data>>

      yield (student, component_code, grade, normalized_date)
@

We need the start of the course and the length to be able to normalize the 
dates for the grades.
<<compute start and length of the course>>=
course_start = course_round.start
course_length = course_round.end - course_start
@

We must get the results for the course round from LADOK.
For this we must use an instance ID of a component.
However, LADOK returns the results for all components, not just the one 
requested for.
<<get the results for the course round>>=
component = course_round.components()[0]
results = ladok.search_course_results(
  course_round.round_id, component.instance_id)["Resultat"]
@

Depending on whether the data is attested or not, we can get the actual grade 
and date from two different substructures:
\enquote{Arbetsunderlag} are results in LADOK that have been entered, but not 
attested;
\enquote{SenastAttesteradeResultat} are results that have been attested.
They both have the same structure.
<<get the component result data>>=
if "Arbetsunderlag" in component_result:
  result_data = component_result["Arbetsunderlag"]
elif "SenastAttesteradeResultat" in component_result:
  result_data = component_result["SenastAttesteradeResultat"]
else:
  continue
@

The results only refer to the component's instance ID, so we must match the 
component on that ID.
The [[course_round]] object allows us to do exactly that with the 
[[components]] method.
We note that we can ignore the grade on the whole course, since that one is 
determined by the other components.
<<extract component code from result data>>=
matching_component = course_round.components(
  instance_id=result_data["UtbildningsinstansUID"])
if len(matching_component) < 1:
  continue
component_code = matching_component[0].code
@

Finally, if there is a grade, we can extract the grade and compute the 
normalized date.
However, if there are no results, we set [[None]].
<<extract grade and normalized date from result data>>=
if "Betygsgradsobjekt" in result_data:
  grade = result_data["Betygsgradsobjekt"]["Kod"]
  date = datetime.date.fromisoformat(
    result_data["Examinationsdatum"])
  normalized_date = (date - course_start) / course_length
else:
  grade = "-"
  normalized_date = None
@


\subsection{Clean the data}

We want to filter out some values from the data.
We only want to keep students who are registered on the course the first time.
<<data functions>>=
def clean_data(data):
  data = list(data)
  students_to_remove = reregistered_students(data)
  return remove_students(students_to_remove, data)
@

We approximate first time registrations with grades reported before the course 
started.
Thus we remove any student who has a result before the course.
It would be more exact to remove students who are in fact reregistered in 
LADOK, but we leave that for a future version.
<<data functions>>=
def reregistered_students(data):
  students = set()
  for student, _, _, time in data:
    if time and time < 0:
      students.add(student)
  return students

def remove_students(students, data):
  for row in data:
    if row[0] not in students:
      yield row
@


\section{Grade distributions}\label{GradeDistributions}

Here we provide the program~[[stats-grade-dist.py]], which computes the grade 
distribution for course rounds.

We will read the data in CSV form, so we need the [[csv]] module.
We read the data from standard input.
<<stats-grade-dist.py>>=
import argparse
import csv
import matplotlib
import matplotlib.pyplot as plt
import pandas as pd
import sys

def main():
  parser = argparse.ArgumentParser(
    description="Compute grade distributions for course rounds")

  <<add grade-dist command-line arguments to parser>>
  args = parser.parse_args()
  data = pd.read_csv(sys.stdin)
  <<compute the grade distributions for data based on args>>

if __name__ == "__main__":
  main()
@

We want to group rows on various attributes.
We have one argument for selecting which attribute (column) to group by.
Then we need two more arguments to select which values should fit into which 
group.
<<add grade-dist command-line arguments to parser>>=
parser.add_argument("-g", "--group-by", default="Round",
  help="The column name to group by")
parser.add_argument("-G", "--groups", nargs="+", action="append",
  help="The values of each group, groups separated by semicolon (;)")
@

The construction above lets us add [[-G]] several times.
Each time with a new group.
<<set up groups to iterate over>>=
groups = []
if args.groups:
  groups = args.groups
else:
  groups = [[group] for group in data[args.group_by].unique()]
@

\subsection{Computing the grade distributions}

Now we can compute the grade distribution for each group.
However, we might want the results in different forms: do we want the results 
normalized or as cumulative counts?
<<add grade-dist command-line arguments to parser>>=
parser.add_argument("-n", "--normalize", action="store_true", default=False,
  help="Normalize counts")
@

Then we can compute the grade distributions as follows.
<<compute the grade distributions for data based on args>>=
<<set up groups to iterate over>>

stats = pd.DataFrame(index=data.Grade.unique())

for group in groups:
  group_data = data[data[args.group_by].isin(group)]
  group_name = "+".join(group)
  stats[group_name] = group_data.groupby("Grade")["Student"].count()
  if args.normalize:
    stats[group_name] /= len(group_data.Student.unique())

stats.sort_index(inplace=True)
<<print the stats>>
@

\subsection{Outputting the stats}

We want to print the stats.
We want to print it plainly for exploration.
We also want to print a \LaTeX-formatted version for easy inclusion in 
documents.
<<add grade-dist command-line arguments to parser>>=
parser.add_argument("-L", "--LaTeX", action="store_true",
  help="Print results LaTeX formatted")
@

We also want to control if we should print the transpose of the table of not.
<<add grade-dist command-line arguments to parser>>=
parser.add_argument("-T", "--transpose", action="store_true",
  help="Print table transposed")
@

We also want to produce a figure to visualize the data.
We want to provide an option for the file name.
<<add grade-dist command-line arguments to parser>>=
parser.add_argument("-f", "--fig-out",
  help="Filename for saving figure of data")
@

Now, we can just check if these flags are set or not.
<<print the stats>>=
if args.transpose:
  old_stats = stats
  stats = stats.transpose()

if args.LaTeX:
  print(stats.to_latex())
else:
  print(stats)

if args.transpose:
  stats = old_stats

matplotlib.use("pgf")
matplotlib.rcParams.update({
  "pgf.texsystem": "pdflatex",
  'font.family': 'serif',
  'text.usetex': True,
  'pgf.rcfonts': False,
})

if "fig_out" in args:
  stats.plot.bar()
  plt.savefig(args.fig_out)
@


\subsection{Example analyses}

We performed some analyses on the courses DD1315, DD1310, DD1312.
DD1315 is covered in \cref{%
  DD1315-all-figure,DD1315-all-table,%
  DD1315-grouped-figure,DD1315-grouped-table,%
  DD1315-last-figure,DD1315-last-table%
}.
DD1310 is covered in \cref{%
  DD1310-all-figure,DD1310-all-table,%
  DD1310-grouped-figure,DD1310-grouped-table,%
}.
DD1312 is covered in \cref{%
  DD1312-all-figure,DD1312-all-table,%
  DD1312-grouped-figure,DD1312-grouped-table,%
}

\begin{figure}
\centering
\input{DD1315-all.pgf}
\caption{All rounds of DD1315 separately.}
\label{DD1315-all-figure}
\end{figure}

\begin{table}
\centering
\input{DD1315-all.tex}
\caption{All rounds of DD1315 separately.}
\label{DD1315-all-table}
\end{table}

\begin{figure}
\centering
\input{DD1315-grouped.pgf}
\caption{Rounds of DD1315 suitably grouped.}
\label{DD1315-grouped-figure}
\end{figure}

\begin{table}
\centering
\input{DD1315-grouped.tex}
\caption{Rounds of DD1315 suitably grouped.}
\label{DD1315-grouped-table}
\end{table}

\begin{figure}
\centering
\input{DD1315-last.pgf}
\caption{All rounds of DD1315 grouped together, except the last.}
\label{DD1315-last-figure}
\end{figure}

\begin{table}
\centering
\input{DD1315-last.tex}
\caption{All rounds of DD1315 grouped together, except the last.}
\label{DD1315-last-table}
\end{table}

\begin{figure}
\centering
\input{DD1310-all.pgf}
\caption{All rounds of DD1310 separately.}
\label{DD1310-all-figure}
\end{figure}

\begin{table}
\centering
\input{DD1310-all.tex}
\caption{All rounds of DD1310 separately.}
\label{DD1310-all-table}
\end{table}

\begin{figure}
\centering
\input{DD1310-grouped.pgf}
\caption{All rounds of DD1310 grouped suitably together.}
\label{DD1310-grouped-figure}
\end{figure}

\begin{table}
\centering
\input{DD1310-grouped.tex}
\caption{All rounds of DD1310 grouped suitably together.}
\label{DD1310-grouped-table}
\end{table}

\begin{figure}
\centering
\input{DD1312-all.pgf}
\caption{All rounds of DD1312 separately.}
\label{DD1312-all-figure}
\end{figure}

\begin{table}
\centering
\input{DD1312-all.tex}
\caption{All rounds of DD1312 separately.}
\label{DD1312-all-table}
\end{table}

\begin{figure}
\centering
\input{DD1312-grouped.pgf}
\caption{All rounds of DD1312 grouped suitably together.}
\label{DD1312-grouped-figure}
\end{figure}

\begin{table}
\centering
\input{DD1312-grouped.tex}
\caption{All rounds of DD1312 grouped suitably together.}
\label{DD1312-grouped-table}
\end{table}

